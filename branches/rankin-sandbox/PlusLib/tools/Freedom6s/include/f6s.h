/*============================================================================
                    Copyright (c) 2004 MPB Technologies Inc.
                              All Rights Reserved

      This is unpublished proprietary source code of MPB Technologies Inc.
            No part of this software may be disclosed or published 
          without the expressed written consent of MPB Technologies Inc.
==============================================================================
    This file defines the interface for the Freedom6S API DLL for use with
    MPB Technologies' force-feedback hand controller devices.
============================================================================*/

#ifndef _F6S_H_
#define _F6S_H_

/* Note: If d3d.h has been included before this file, **
** Direct3D-compatible routines will be defined.      */

#ifdef WIN32
  #ifdef F6S_EXPORTS
    #define F6S_API
  #include <d3d.h>
  #else
  #ifdef __cplusplus
    #define F6S_API extern "C" __declspec(dllimport)
  #else
    #define F6S_API __declspec(dllimport)
  #endif
    #ifndef _D3D_H_
      #define LPD3DMATRIX void*
    #endif
  #endif
#else
  #ifdef __cplusplus
    #define F6S_API extern "C"
  #else
    #ifdef F6S_EXPORTS
      #define F6S_API
    #else
      #define F6S_API extern
    #endif
  #endif
  #define __stdcall
#endif

/////////////////
// Error Handling
// Please note that the callback error handling method
// has been made obsolete in favour of the simple return
// codes listed below.  Please update your code to use
// them, and f6s_GetLastErrorString() for more detailed
// error information.

// Types of error messages generated by the Freedom6S library (obsolete)

typedef enum
{
    F6SET_ERROR,  // Fatal
    F6SET_WARNING,  // Abnormal
    F6SET_DEBUG    // Informational
} F6sErrorType;

// Prototype for the application-defined error handler function (obsolete)
typedef void (__stdcall APPERRORHANDLER) (F6sErrorType nErrorType, char *szErrorString);

//////////////////
// Power Detection

// These flags are used to report power on/off status.
// Power status can be retrieved via Freedom6S::GetPowerStatus().
// Note that not all configurations support power detection.

#define F6SPS_SENSORS  0x01
#define F6SPS_MOTORS  0x02
#define F6SPS_OFF    0
#define F6SPS_UNKNOWN  -1
#define F6SPS_UNPLUGGED  -2

////////////////////////
// Safety Feature Flags

#define F6SSF_RUNAWAY  0x01  // turn off motors when high velocity is detected (default on)
#define F6SSF_SIGNAL  0x02  // turn off motors when a signal is triggered - ie. segmentation fault (default on)
#define F6SSF_BOUNDARY  0x04  // use virtual box to keep controller within workspace boundaries (default off)
#define F6SSF_BOUNDBUZZ  0x08  // create a haptic buzz when user is close to workspace boundary (default off)

////////////////////////
// F6sDiagData struct

// This struct will contain diagnostic information on the hand controller.
// The structure data are updated by a call to Freedom6S::GetDiagData().
// Sensor 4 is the Roll Sensor; Sensor 5 is the Quad Roll Sensor

typedef struct
{
    float  m_Sensors[8];        // sensor voltages
    double  m_Angles[7];        // computed sensor angles
    float  m_O5a, m_O5b, m_O5c, m_O5d;  // Sensor 4-5 overlaps, in degrees.
    char  m_bZeroSide;        // true if Sensor 4 is on + side of zero angle
  double  m_MotorJacobian[36];    // 6x6 jacobian used to compute joint torques
} F6sDiagData;

////////////////
// Return codes

typedef enum
{
  F6SRC_NOERROR      =  0,
  F6SRC_ALREADYEXIST    =  -1,    /* A Freedom6S device is already open in the system                                */
  F6SRC_BADVALUE      =  -2,    /* Value out of range                                                              */
  F6SRC_BADPOINTER    =  -3,    /* Bad pointer passed to function                                                  */
  F6SRC_MEMORY      =  -4,    /* Out of memory                                                                   */
  F6SRC_REGISTRY      =  -5,    /* Error reading registry values (will user defaults)                              */
  F6SRC_INIFILE_READ    =  -6,    /* Error reading ini file (settings)                                               */
  F6SRC_INIFILE_WRITE    =  -7,    /* Error writing ini file (settings)                                               */
  F6SRC_NOTINITIALIZED  =  -8,    /* Attempt to call a function before f6s_Initialize()                              */
  F6SRC_BADHANDLE      =  -9,    /* A function received a bad HF6S value                                            */
  F6SRC_BADMOTORTEMP    =  -10,  /* Motor temperatures were out of range or not read correctly (warning only)       */
  F6SRC_JOINTVELINIT    =  -11,  /* Attempt to read velocity without joint velocity computation enabled             */
  F6SRC_CALIBRATION    =  -12,  /* Unable to calibrate, require mechanical calibration                             */
  F6SRC_ROLLANGLE      =  -13,  /* Unable to calculate roll angle, sensors 4 & 5 require mechanical re-calibration */
  F6SRC_DRIVERINIT    =  -14,  /* Unable to initialize the drivers for ADC or DAC hardware                        */
  F6SRC_IOERROR      =  -15,  /* Error returned from ADC or DAC drivers                                          */
  F6SRC_DAQCONFIG      =  -16,  /* Unknown DAQ configuration                             */
  F6SRC_HOTMOTOR      =   -17,     /* One or more motors have been flagged hot, causing the max current to decrease   */
  F6SRC_FAILURE           =   -18     /* Operation failed                                                                */
} F6SRC;

////////////////////////
// F6sDeviceInfo struct

typedef enum { F6SDT_FREEDOM6S, F6SDT_CUBIC } F6sDeviceType;
typedef enum { F6SHT_NORMAL, F6SHT_BUTTON } F6sHandleType;

// Information on the device.  This structure is passed by pointer
// because it remains unchanged througout the life of the HF6S handle.
typedef struct F6sDeviceInfo_
{
  char *m_strSerialNo;      // serial number
  F6sDeviceType m_nDeviceType;  // device type identifier
  F6sHandleType m_nHandleType;  // type of handle featured on the device
  char m_nDOF;          // degrees of freedom
  char m_nJoints;          // number of joints
  char m_nMotors;          // number of motors
  char m_nSensors;        // number of sensors
  char m_bLeftDevice;        // true for left-handed devices
  char m_bLeftHandle;        // true for left-handled devices
} F6sDeviceInfo;

///////////////////////////////
// Handle to a Freedom6S object
typedef void* HF6S;

//
// Entry functions for the DLL
//
// Initialization/Cleanup
F6S_API F6SRC f6s_Initialize( HF6S* phf6s );
F6S_API F6SRC f6s_ComputeJointVel( HF6S hf6s, float ftimeStep, int inewBufferSize );
F6S_API F6SRC f6s_Cleanup( HF6S hf6s );

// Retrieve error information.
// Returns number of error strings available, including the one retrieved.
F6S_API int f6s_GetLastErrorString( HF6S hf6s, char* strBuffer, int nBufferSize );

// Set parameters
F6S_API F6SRC f6s_SetHoldDist( HF6S hf6s, float fdist );
F6S_API F6SRC f6s_SetBaseAngles( HF6S hf6s, const double knobAng[3] );
F6S_API F6SRC f6s_SetJointAngles( HF6S hf6s, const double *jointAngles, int nJoints );
F6S_API F6SRC f6s_SetForceTorque( HF6S hf6s, const double force[3], const double torque[3] );
F6S_API F6SRC f6s_SetForceTorqueGL( HF6S hf6s, const double force[3], const double torque[3] );
#ifdef _D3D_H_
F6S_API F6SRC f6s_SetForceTorqueD3D( HF6S hf6s, LPD3DVECTOR force, LPD3DVECTOR torque );
#endif
F6S_API F6SRC f6s_SetJointTorques( HF6S hf6s, double *jointTorques, int nJoints );
F6S_API F6SRC f6s_SetMotorVoltages( HF6S hf6s, double *motorVolts, int nMotors );
F6S_API F6SRC f6s_SetSafetyFeatures( HF6S hf6s, unsigned int flags );

// Update kinematics
F6S_API F6SRC f6s_UpdateKinematics( HF6S hf6s );

// Get information
F6S_API F6SRC f6s_GetPositionMatrix( HF6S hf6s, double kineMat[4][4] );
F6S_API F6SRC f6s_GetPositionMatrixGL( HF6S hf6s, double kineMat[16] );
#ifdef _D3D_H_
F6S_API F6SRC f6s_GetPositionMatrixD3D( HF6S hf6s, LPD3DMATRIX kineMat );
F6S_API F6SRC f6s_GetPositionVectorsD3D( HF6S hf6s, LPD3DVECTOR pos, LPD3DVECTOR dir, LPD3DVECTOR up );
#endif
F6S_API F6SRC f6s_GetVelocity( HF6S hf6s, double linearVel[3],  double angularVel[3] );
F6S_API F6SRC f6s_GetVelocityGL( HF6S hf6s, double linearVel[3],  double angularVel[3] );
#ifdef _D3D_H_
F6S_API F6SRC f6s_GetVelocityD3D( HF6S hf6s, LPD3DVECTOR linearVel,  LPD3DVECTOR angularVel );
#endif
F6S_API F6SRC f6s_GetJointAngles( HF6S hf6s, double *jointAngles, int nJoints );
F6S_API F6SRC f6s_GetJointVelocities( HF6S hf6s, double *jointVelocities, int nJoints );
F6S_API F6SRC f6s_GetButtonPressed( HF6S hf6s, int *pbPressed );
F6S_API F6SRC f6s_GetDiagData( HF6S hf6s, F6sDiagData* pDiag, int nDiagDataSize );
F6S_API F6SRC f6s_GetVersion( HF6S hf6s, char* strVersion, int nVersionLen, char* strDate, int nDateLen );
F6S_API F6SRC f6s_GetDeviceInfo( HF6S hf6s, F6sDeviceInfo* pDevInfo, int nDevInfoLen );
F6S_API  F6SRC f6s_GetPowerStatus( HF6S hf6s, int *pnPowerStatus );
F6S_API F6SRC f6s_GetForceTorque( HF6S hf6s, double force[3],  double torque[3] );
F6S_API F6SRC f6s_GetJointTorques( HF6S hf6s, double *jointTorques, int nJoints );
F6S_API F6SRC f6s_GetBoundaryDetect( HF6S hf6s, int *pbOutsideBoundary );
F6S_API F6SRC f6s_GetSafetyFeatures( HF6S hf6s, unsigned int *pnSafety );

// Manipulate vectors according to device axes & current handle position
F6S_API F6SRC f6s_TransformPointToHome( HF6S hf6s, double homePoint[3], const double fromPoint[3] );
F6S_API F6SRC f6s_TransformDirectionToHome( HF6S hf6s, double homeDir[3], const double fromDir[3] );
F6S_API F6SRC f6s_TransformPointToHandle( HF6S hf6s, double handlePoint[3], const double fromPoint[3] );
F6S_API F6SRC f6s_TransformDirectionToHandle( HF6S hf6s, double handleDir[3], const double fromDir[3] );
F6S_API F6SRC f6s_GetPointVelocityHandle( HF6S hf6s, double velocity[3], const double point[3]);

// Sleep with (ideally) microsecond precision
F6S_API F6SRC f6s_SetTimer( HF6S hf6s, int usec );
F6S_API F6SRC f6s_SleepTimer( HF6S hf6s );
F6S_API F6SRC f6s_KillTimer( HF6S hf6s );

#ifdef __KERNEL__
// Set configuration from a kernel mode ioctl routine
// This must be called before f6s_Initialize()
F6S_API int f6s_SetConfig_IOCTL( unsigned long ioctl_param );
#endif // __KERNEL_

#ifndef _D3D_H_
#undef LPD3DMATRIX
#endif

#endif
